<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Облако слов — экран</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Стили -->
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: linear-gradient(135deg, #fbe9ff, #f1f5ff);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .page {
      width: 95vw;
      height: 85vh;
      max-width: 1300px;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 24px;
      padding: 24px;
      display: flex;
      gap: 24px;
      box-shadow: 0 18px 40px rgba(15,23,42,0.25);
    }
    .cloud-wrapper {
      flex: 1;
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      overflow: hidden;
      background: rgba(248, 250, 252, 0.9);
      position: relative;
    }
    .cloud-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .cloud-wrapper {
      animation: float 20s ease-in-out infinite;
    }
    @keyframes float {
      0%, 100% {
        transform: translate(0, 0);
      }
      25% {
        transform: translate(2px, -3px);
      }
      50% {
        transform: translate(-2px, 2px);
      }
      75% {
        transform: translate(3px, 1px);
      }
    }
    .side {
      width: 260px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      text-align: center;
    }
    .side-question {
      font-size: 1rem;
      margin-bottom: 4px;
    }
    .side-qr {
      width: 180px;
      height: 180px;
      border-radius: 16px;
      background: white;
      padding: 8px;
      box-shadow: 0 10px 25px rgba(15,23,42,0.25);
    }
    .side-hint {
      font-size: 0.9rem;
      color: #4b5563;
    }
    .side-link {
      font-size: 0.85rem;
      color: #4338ca;
      word-break: break-all;
    }
    @media (max-width: 900px) {
      .page {
        flex-direction: column;
        height: auto;
        min-height: 100vh;
      }
      .side {
        width: 100%;
        margin-top: 12px;
      }
      .cloud-wrapper {
        min-height: 50vh;
      }
    }
  </style>

  <!-- React + ReactDOM + Babel (для JSX прямо в браузере) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

  <!-- Socket.io client -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

  <!-- wordcloud2 -->
  <script src="https://cdn.jsdelivr.net/npm/wordcloud@1.2.2/src/wordcloud2.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    function CloudApp() {
      const [counts, setCounts] = React.useState({});
      const [question, setQuestion] = React.useState('Загрузка вопроса…');
      const canvasRef = React.useRef(null);
      const prevCountsRef = React.useRef({});
      const animationFrameRef = React.useRef(null);

      const voteUrl = window.location.origin + '/vote';
      const qrSrc =
        'https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=' +
        encodeURIComponent(voteUrl);

      // Загружаем текст вопроса
      React.useEffect(() => {
        fetch('/api/config')
          .then((r) => r.json())
          .then((cfg) => {
            setQuestion(cfg.question || 'Облако слов');
          })
          .catch(() => setQuestion('Облако слов'));
      }, []);

      // Подключаемся к Socket.io
      React.useEffect(() => {
        const socket = io({
          transports: ['websocket', 'polling'],
          reconnection: true,
          reconnectionDelay: 1000,
          reconnectionAttempts: 5
        });
        
        socket.on('connect', () => {
          console.log('Socket.io подключен:', socket.id);
        });
        
        socket.on('disconnect', () => {
          console.log('Socket.io отключен');
        });
        
        socket.on('connect_error', (error) => {
          console.error('Ошибка подключения Socket.io:', error);
        });
        
        socket.on('wordcloud:update', (data) => {
          console.log('Получено обновление облака:', data);
          const newCounts = data || {};
          // Плавный переход к новым данным
          prevCountsRef.current = counts;
          setCounts(newCounts);
        });
        
        return () => {
          console.log('Отключение Socket.io');
          socket.disconnect();
        };
      }, []);

      // Рисуем облако с анимацией при изменении counts или при ресайзе
      React.useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        let animationStart = Date.now();
        const animationDuration = 1000; // 1 секунда на анимацию
        const prevCounts = prevCountsRef.current;

        function draw(progress = 1) {
          const entries = Object.entries(counts || {});
          const ctx = canvas.getContext('2d');

          // выставляем размер под контейнер
          canvas.width = canvas.clientWidth;
          canvas.height = canvas.clientHeight;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          if (!entries.length) {
            ctx.fillStyle = '#6b7280';
            ctx.font = '24px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Пока нет ответов',
              canvas.width / 2,
              canvas.height / 2
            );
            return;
          }

          // Ограничиваем количество слов для производительности (топ-30)
          const limitedEntries = entries
            .sort((a, b) => b[1] - a[1])
            .slice(0, 30);
          
          if (!limitedEntries.length) return;
          
          // Нормализуем значения относительно максимального
          const maxCount = Math.max(...limitedEntries.map(([_, c]) => c), 1);
          const minCount = Math.min(...limitedEntries.map(([_, c]) => c), 1);
          
          // Интерполируем между старыми и новыми значениями для плавной анимации
          const normalizedList = limitedEntries.map(([word, count]) => {
            const prevCount = prevCounts[word] || 0;
            
            // Плавный переход от старого к новому значению
            const interpolatedCount = prevCount + (count - prevCount) * progress;
            
            // Нормализуем к диапазону 20-80 (уменьшили для меньшего потребления памяти)
            const normalized = minCount === maxCount 
              ? 50
              : 20 + ((interpolatedCount - minCount) / (maxCount - minCount)) * 60;
            return [word, normalized];
          });

          const palette = ['#4f46e5', '#22c55e', '#f97316', '#ec4899', '#0ea5e9', '#facc15'];

          // Вычисляем weightFactor на основе размера canvas
          const base = Math.min(canvas.width, canvas.height);
          const weightFactor = base / 15; // Увеличили делитель для меньших размеров
          
          // Ограничиваем размер canvas для предотвращения ошибок памяти
          const maxCanvasSize = 1200; // Максимальный размер canvas
          if (canvas.width > maxCanvasSize || canvas.height > maxCanvasSize) {
            const scale = Math.min(maxCanvasSize / canvas.width, maxCanvasSize / canvas.height);
            canvas.width = Math.floor(canvas.width * scale);
            canvas.height = Math.floor(canvas.height * scale);
          }

          try {
            WordCloud(canvas, {
              list: normalizedList,
              weightFactor,
              rotateRatio: 0,
              backgroundColor: 'rgba(0,0,0,0)',
              color: () => palette[Math.floor(Math.random() * palette.length)],
              shrinkToFit: true,
              drawOutOfBound: false,
              minSize: 10,
              gridSize: Math.max(8, Math.floor(base / 80)), // Увеличили gridSize для меньшего потребления памяти
              fontFamily: 'system-ui, -apple-system, sans-serif',
              fontWeight: 'normal',
              maxRotation: 0,
              minRotation: 0
            });
          } catch (error) {
            console.error('Ошибка при отрисовке облака:', error);
            // Показываем сообщение об ошибке
            ctx.fillStyle = '#ef4444';
            ctx.font = '18px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Ошибка отрисовки. Попробуйте обновить страницу.',
              canvas.width / 2,
              canvas.height / 2
            );
          }
        }

          // Анимация перехода (только если есть изменения)
        const hasChanges = JSON.stringify(prevCounts) !== JSON.stringify(counts);
        
        if (hasChanges && Object.keys(prevCounts).length > 0) {
          function animate() {
            const elapsed = Date.now() - animationStart;
            const progress = Math.min(elapsed / animationDuration, 1);
            
            // Easing функция для плавности
            const easedProgress = progress < 0.5 
              ? 2 * progress * progress 
              : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            
            draw(easedProgress);
            
            if (progress < 1) {
              animationFrameRef.current = requestAnimationFrame(animate);
            } else {
              // Анимация завершена, обновляем предыдущие значения
              prevCountsRef.current = counts;
            }
          }

          // Запускаем анимацию
          animationStart = Date.now();
          animate();
        } else {
          // Нет изменений или первая отрисовка - рисуем сразу
          draw(1);
          prevCountsRef.current = counts;
        }

        // Обработчик ресайза
        const handleResize = () => {
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
          draw(1);
        };

        window.addEventListener('resize', handleResize);
        
        return () => {
          window.removeEventListener('resize', handleResize);
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
        };
      }, [counts]);

      return (
        <div className="page">
          <div className="cloud-wrapper">
            <canvas ref={canvasRef} className="cloud-canvas" />
          </div>
          <div className="side">
            <h2 className="side-question">{question}</h2>
            <img src={qrSrc} alt="QR-код для ответа" className="side-qr" />
            <p className="side-hint">
              Сканируйте QR-код, чтобы ответить на вопрос.
            </p>
            <p className="side-link">{voteUrl}</p>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CloudApp />);
  </script>
</body>
</html>

