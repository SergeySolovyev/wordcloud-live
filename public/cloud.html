<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Облако слов — экран</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Стили -->
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; }
    body {
      font-family: 'Segoe UI', 'Roboto', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #60a5fa 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .page {
      width: 95vw;
      height: 85vh;
      max-width: 1400px;
      background: #ffffff;
      border-radius: 16px;
      padding: 32px;
      display: flex;
      gap: 32px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .cloud-wrapper {
      flex: 1;
      border-radius: 12px;
      border: 2px solid #e5e7eb;
      overflow: hidden;
      background: #f9fafb;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
    }
    .cloud-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .side {
      width: 280px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      text-align: center;
      background: linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%);
      border-radius: 12px;
      padding: 24px;
      border: 1px solid #e2e8f0;
    }
    .side-question {
      font-size: 1.1rem;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 8px;
      line-height: 1.4;
    }
    .side-qr {
      width: 200px;
      height: 200px;
      border-radius: 12px;
      background: white;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
      border: 2px solid #e5e7eb;
    }
    .side-hint {
      font-size: 0.9rem;
      color: #64748b;
      font-weight: 500;
    }
    .side-link {
      font-size: 0.8rem;
      color: #3b82f6;
      word-break: break-all;
      font-weight: 500;
      background: rgba(59, 130, 246, 0.1);
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(59, 130, 246, 0.2);
    }
    .reset-btn {
      margin-top: 8px;
      padding: 6px 12px;
      font-size: 0.75rem;
      font-weight: 500;
      color: #dc2626;
      background: rgba(220, 38, 38, 0.1);
      border: 1px solid rgba(220, 38, 38, 0.3);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .reset-btn:hover {
      background: rgba(220, 38, 38, 0.15);
      border-color: rgba(220, 38, 38, 0.4);
    }
    @media (max-width: 900px) {
      .page {
        flex-direction: column;
        height: auto;
        min-height: 100vh;
      }
      .side {
        width: 100%;
        margin-top: 12px;
      }
      .cloud-wrapper {
        min-height: 50vh;
      }
    }
  </style>

  <!-- React + ReactDOM + Babel (для JSX прямо в браузере) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

  <!-- Socket.io client -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

  <!-- wordcloud2 -->
  <script src="https://cdn.jsdelivr.net/npm/wordcloud@1.2.2/src/wordcloud2.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    function CloudApp() {
      const [counts, setCounts] = React.useState({});
      const [question, setQuestion] = React.useState('Загрузка вопроса…');
      const canvasRef = React.useRef(null);
      const prevCountsRef = React.useRef({});
      const animationFrameRef = React.useRef(null);

      const voteUrl = window.location.origin + '/vote';
      const qrSrc =
        'https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=' +
        encodeURIComponent(voteUrl);

      // Загружаем текст вопроса
      React.useEffect(() => {
        fetch('/api/config')
          .then((r) => r.json())
          .then((cfg) => {
            setQuestion(cfg.question || 'Облако слов');
          })
          .catch(() => setQuestion('Облако слов'));
      }, []);

      // Подключаемся к Socket.io
      React.useEffect(() => {
        const socket = io({
          transports: ['websocket', 'polling'],
          reconnection: true,
          reconnectionDelay: 1000,
          reconnectionAttempts: 5
        });
        
        socket.on('connect', () => {
          console.log('Socket.io подключен:', socket.id);
        });
        
        socket.on('disconnect', () => {
          console.log('Socket.io отключен');
        });
        
        socket.on('connect_error', (error) => {
          console.error('Ошибка подключения Socket.io:', error);
        });
        
        socket.on('wordcloud:update', (data) => {
          console.log('Получено обновление облака:', data);
          const newCounts = data || {};
          // Плавный переход к новым данным
          prevCountsRef.current = counts;
          setCounts(newCounts);
        });
        
        return () => {
          console.log('Отключение Socket.io');
          socket.disconnect();
        };
      }, []);

      // Рисуем облако с анимацией при изменении counts или при ресайзе
      React.useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        let animationStart = Date.now();
        const animationDuration = 1000; // 1 секунда на анимацию
        const prevCounts = prevCountsRef.current;

        function draw(progress = 1) {
          const entries = Object.entries(counts || {});
          const ctx = canvas.getContext('2d');

          // Ограничиваем максимальный размер canvas для предотвращения ошибок памяти
          const maxCanvasSize = 1200; // Максимальный размер canvas
          const clientWidth = Math.min(canvas.clientWidth, maxCanvasSize);
          const clientHeight = Math.min(canvas.clientHeight, maxCanvasSize);
          
          canvas.width = clientWidth;
          canvas.height = clientHeight;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          if (!entries.length) {
            ctx.fillStyle = '#6b7280';
            ctx.font = '24px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Пока нет ответов',
              canvas.width / 2,
              canvas.height / 2
            );
            return;
          }

          // Ограничиваем количество слов для производительности (топ-20)
          const limitedEntries = entries
            .sort((a, b) => b[1] - a[1])
            .slice(0, 20);
          
          if (!limitedEntries.length) return;
          
          // Нормализуем значения относительно максимального
          const maxCount = Math.max(...limitedEntries.map(([_, c]) => c), 1);
          const minCount = Math.min(...limitedEntries.map(([_, c]) => c), 1);
          
          // Интерполируем между старыми и новыми значениями для плавной анимации
          const normalizedList = limitedEntries.map(([word, count]) => {
            const prevCount = prevCounts[word] || 0;
            
            // Плавный переход от старого к новому значению
            const interpolatedCount = prevCount + (count - prevCount) * progress;
            
            // Нормализуем к диапазону 20-60 (уменьшили, чтобы слова не выходили за пределы)
            const normalized = minCount === maxCount 
              ? 40
              : 20 + ((interpolatedCount - minCount) / (maxCount - minCount)) * 40;
            return [word, normalized];
          });

          // Профессиональная палитра корпоративных цветов
          const palette = ['#1e40af', '#3b82f6', '#2563eb', '#1d4ed8', '#0ea5e9', '#0284c7', '#0369a1', '#075985'];

          // Вычисляем weightFactor на основе размера canvas
          const base = Math.min(canvas.width, canvas.height);
          const weightFactor = base / 25; // Увеличили делитель, чтобы слова были меньше и помещались
          
          // Уменьшаем gridSize для лучшей видимости (но не слишком маленький для памяти)
          const gridSize = Math.max(8, Math.floor(base / 100));

          try {
            WordCloud(canvas, {
              list: normalizedList,
              weightFactor,
              rotateRatio: 0,
              backgroundColor: 'rgba(0,0,0,0)',
              color: () => palette[Math.floor(Math.random() * palette.length)],
              shrinkToFit: true,
              drawOutOfBound: false,
              minSize: 14, // Минимальный размер
              gridSize: gridSize, // Увеличенный gridSize для экономии памяти
              maxSize: 60, // Максимальный размер, чтобы слова не выходили за пределы
              fontFamily: 'system-ui, -apple-system, sans-serif',
              fontWeight: 'normal',
              maxRotation: 0,
              minRotation: 0
            });
          } catch (error) {
            console.error('Ошибка при отрисовке облака:', error);
            // Показываем сообщение об ошибке
            ctx.fillStyle = '#ef4444';
            ctx.font = '18px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Ошибка отрисовки. Попробуйте обновить страницу.',
              canvas.width / 2,
              canvas.height / 2
            );
          }
        }

          // Анимация перехода (только если есть изменения)
        const hasChanges = JSON.stringify(prevCounts) !== JSON.stringify(counts);
        
        if (hasChanges && Object.keys(prevCounts).length > 0) {
          function animate() {
            const elapsed = Date.now() - animationStart;
            const progress = Math.min(elapsed / animationDuration, 1);
            
            // Easing функция для плавности
            const easedProgress = progress < 0.5 
              ? 2 * progress * progress 
              : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            
            draw(easedProgress);
            
            if (progress < 1) {
              animationFrameRef.current = requestAnimationFrame(animate);
            } else {
              // Анимация завершена, обновляем предыдущие значения
              prevCountsRef.current = counts;
            }
          }

          // Запускаем анимацию
          animationStart = Date.now();
          animate();
        } else {
          // Нет изменений или первая отрисовка - рисуем сразу
          draw(1);
          prevCountsRef.current = counts;
        }

        // Обработчик ресайза
        const handleResize = () => {
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
          draw(1);
        };

        window.addEventListener('resize', handleResize);
        
        return () => {
          window.removeEventListener('resize', handleResize);
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
        };
      }, [counts]);

      return (
        <div className="page">
          <div className="cloud-wrapper">
            <canvas ref={canvasRef} className="cloud-canvas" />
          </div>
          <div className="side">
            <h2 className="side-question">{question}</h2>
            <img src={qrSrc} alt="QR-код для ответа" className="side-qr" />
            <p className="side-hint">
              Сканируйте QR-код, чтобы ответить на вопрос.
            </p>
            <p className="side-link">{voteUrl}</p>
            <button 
              className="reset-btn" 
              onClick={async () => {
                if (confirm('Сбросить все результаты?')) {
                  try {
                    await fetch('/api/reset', { method: 'POST' });
                  } catch (e) {
                    console.error('Ошибка сброса:', e);
                  }
                }
              }}
            >
              Сброс
            </button>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CloudApp />);
  </script>
</body>
</html>

